<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>让我们揭开 JavaScript 关键字 new 的神秘面纱
| 天心阁</title><link href=/favicon.ico rel="shortcut icon" type=image/x-icon><meta name=author content="苏夏天心"><meta name=description content="天地人心"><meta name=generator content="Hugo 0.95.0"><link rel=canonical href=https://barryyan.github.io/program/javascript-the-new-keyword/><meta property="og:title" content="让我们揭开 JavaScript 关键字 new 的神秘面纱"><meta property="og:description" content="周末, 我完成了 Will Sentance 的《JavaScript: The Hard Parts》课程. 听起来也许这并不是度过周末最光荣的方式, 但是实际上我觉得完成这门课很轻松, 也很有趣. 它涉及到了函数式编程, 高阶函数, 闭包以及异步 JavaScript的内容."><meta property="og:type" content="article"><meta property="og:url" content="https://barryyan.github.io/program/javascript-the-new-keyword/"><meta property="article:section" content="program"><meta property="article:published_time" content="2020-03-29T00:59:54+08:00"><meta property="article:modified_time" content="2020-03-29T00:59:54+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="让我们揭开 JavaScript 关键字 new 的神秘面纱"><meta name=twitter:description content="周末, 我完成了 Will Sentance 的《JavaScript: The Hard Parts》课程. 听起来也许这并不是度过周末最光荣的方式, 但是实际上我觉得完成这门课很轻松, 也很有趣. 它涉及到了函数式编程, 高阶函数, 闭包以及异步 JavaScript的内容."><link rel=stylesheet href=/css/github-markdown.css><link rel=stylesheet href=/css/semantic.min.css><link rel=stylesheet href=/css/site.css><style>a{color:#00bfff!important}</style><style>.inverted a{color:#87cefa!important}</style></head><body style=background-image:url(/me/bg.jpeg)><div class=flip-container><div class=flipper><section class=front><nav class="ui secondary inverted menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick='window.location.href="https://barryyan.github.io"'></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div></nav><div class="ui centered relaxed grid dream-grid"><div class="sixteen wide mobile sixteen wide tablet twelve wide computer column markdown-body dream-single"><section class="ui top attached segment" id=dream-save-post-as-img><header style=margin-top:0!important><h2 class="ui header">让我们揭开 JavaScript 关键字 new 的神秘面纱<div class="sub header">@ 苏夏天心 · Sunday, Mar 29, 2020 · 4 分钟阅读 · 更新于 3月 29, 2020</div></h2></header><article style=margin-top:2rem><p>周末, 我完成了 Will Sentance 的<a href=https://frontendmasters.com/courses/javascript-hard-parts/>《JavaScript: The Hard Parts》</a>课程. 听起来也许这并不是度过周末最光荣的方式, 但是实际上我觉得完成这门课很轻松, 也很有趣. 它涉及到了函数式编程, 高阶函数, 闭包以及异步 JavaScript的内容.</p><p>对我来说, 这个课程的亮点是他如何将 JavaScript 的方法扩展到了面向对象编程(OOP), 并揭开了 new 运算符的背后的魔法. 我现在已经全面了解了使用 <code>new</code> 运算符时内部发生了什么.</p><h2 id=javascript-的面向对象编程>JavaScript 的面向对象编程</h2><p><img src=https://cdn-images-1.medium.com/max/1600/0*SjgGIxtpI-X9CnNl. alt></p><p>面向对象编程是一种基于"对象"概念的编程范式.数据和函数(属性和方法)捆绑在一个对象中.</p><p>JavaScript 中的对象是键值对的集合. 这些键值对就是对象的属性. 属性可以是数组, 函数, 对象本身, 或者任何基本数据类型, 比如字符串或数字.</p><p>我们的 JavaScript 工具箱中有哪些用于创建对象的技术呢?</p><p>假设我们正在为我们刚设计的游戏创建用户. 我们将如何存储用户的信息, 例如他们的名字, 点数以及实现诸如点数递增的工具方法呢? 以下是创建基本对象的方法.</p><h3 id=方法1-对象字面量>方法1: 对象字面量</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user1</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Taylor&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>points</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>5</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>increment</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>user1</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>JavaScript 对象字面量是一个用大括号包裹的键值对的列表. 上面的例子中, 我们创建了<code>user1</code>对象, 并在其中存储了相关的数据.</p><h3 id=方法2-objectcreate>方法2: Object.create()</h3><p><code>Object.create(proto, [ propertiesObject ])</code><br><code>Object.create</code> 方法接受两个参数:</p><ol><li>proto: 要创建的对象的原型. 它必须是一个对象或者 <code>null</code>.</li><li>propertiesObject: 新对象的属性. 这个参数是可选的.</li></ol><p>基本上, <code>Object.create</code> 将返回一个继承自你传入对象的新对象.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user2</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>user2</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Cam&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>user2</span>.<span style=color:#a6e22e>points</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>user2</span>.<span style=color:#a6e22e>increment</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>user2</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的基本对象创建选项是重复的, 每一个都需要手动去创建.<br>我们怎么解决这个问题呢?</p><h2 id=解决方案>解决方案</h2><h3 id=方案1-使用函数生成对象>方案1: 使用函数生成对象</h3><p>一个简单的解决方案是编写一个函数来创建新用户.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>points</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>newUser</span> <span style=color:#f92672>=</span> {};
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>points</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>increment</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newUser</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>你现在可以在函数的参数中输入信息来创建用户.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>user1</span>.<span style=color:#a6e22e>increment</span>();
</span></span></code></pre></div><p>但是, 上面示例中的 <code>increment</code> 函数只是对原始 <code>increment</code> 函数的复制. 这不是编写代码的好方法, 如果这个函数有所改动, 你需要对每个对象进行更改.</p><h3 id=方案2-使用-javascript-的原型特性>方案2: 使用 JavaScript 的原型特性</h3><p>与 Python 和 Java 等面向对象的语言不通, JavaScript 没有真正意义上的类. 它使用原型和原型链的概念进行继承.</p><p>当你创建了一个数组, 你自然而然的就可以访问内置方法, 比如 <code>Array.join</code>, <code>Array.sort</code> 和 <code>Array.filter</code> 等. 这是由于数组对象继承了 <code>Array.prototype</code> 的属性.</p><p><img src=https://cdn-images-1.medium.com/max/1600/1*9CKiUI1JDrcJPWfqYdBjFg.png alt=prototype></p><p>每个 JavaScript 函数都有一个默认为空的原型属性. 你可以给这个原型属性添加函数, 这种形式的函数我们称之为方法. 当执行这个继承函数时, 它的 <code>this</code> 指向继承的对象.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>points</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>newUser</span> <span style=color:#f92672>=</span> Object.<span style=color:#a6e22e>create</span>(<span style=color:#a6e22e>userFunction</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>newUser</span>.<span style=color:#a6e22e>points</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>newUser</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>userFunction</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>increment</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>};
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>login</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>function</span>() {<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Please login.&#34;</span>)};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user1</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#e6db74>&#34;Bob&#34;</span>, <span style=color:#ae81ff>5</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>user1</span>.<span style=color:#a6e22e>increment</span>();
</span></span></code></pre></div><p>当创建 <code>user1</code> 对象时, 一个绑定了 <code>userFunction</code> 的原型链就形成了.<br>在堆栈中调用 <code>user1.increment()</code> 时, 解释器会在全局的内存中查找 <code>user1</code>, 然后再查找 <code>increment</code> 函数, 但是不会找到它. 所以解释器会查找原型链上的下一个对象, 并在那里找到 <code>increment</code> 函数.</p><h3 id=方案3-new-和-this-关键字>方案3: new 和 this 关键字</h3><p><img src=https://cdn-images-1.medium.com/max/1600/1*mF32LKAQAr5BrbyON_i6bg.jpeg alt="new and this"></p><p><strong>new 运算符用于创建具有构造函数的对象的实例.</strong></p><p>当我们用 <code>new</code> 来调用构造函数时, 会自动执行以下操作:</p><ul><li>创建一个新对象</li><li>把 <code>this</code> 绑定到新对象</li><li>构造函数的原型对象成为新对象的 <code>__proto__</code> 属性</li><li>返回新对象</li></ul><p>这太棒了, 因为它是自动的, 减少了重复的代码!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>User</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>points</span>) {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>; 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>points</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>increment</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>(){
</span></span><span style=display:flex><span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>login</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>() {
</span></span><span style=display:flex><span> <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#960050;background-color:#1e0010>“</span><span style=color:#a6e22e>Please</span> <span style=color:#a6e22e>login</span>.<span style=color:#960050;background-color:#1e0010>”</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>User</span>(<span style=color:#960050;background-color:#1e0010>“</span><span style=color:#a6e22e>Dylan</span><span style=color:#960050;background-color:#1e0010>”</span>, <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>user1</span>.<span style=color:#a6e22e>increment</span>();
</span></span></code></pre></div><p>使用原型模式, 每个方法和属性都会直接添加到对象的原型上.</p><p>解释器将在原型链上向上查找, 并找到位于 <code>User</code> 上的 <code>increment</code> 函数, 该函数本身也是一个包含信息的对象. 记住 &mdash;- JavaScript 中的所有函数也是对象. 现在解释器已经找到了它所需要的东西, 它可以创建一个新的本地执行上下文来运行 <code>user1.increment</code>.</p><h4 id=附注-__proto__-与-prototype-之间的区别>附注: <code>__proto__</code> 与 <code>prototype</code> 之间的区别</h4><p>如果你已经对 <code>__proto__</code> 和 <code>prototype</code> 感到困惑, 不要担心! 你不是唯一一个对此感到困惑的人.</p><p><code>prototype</code> 是构造函数的属性, 它决定了构造对象上的 <code>__proto__</code> 属性.
因此, <code>__proto__</code> 是创建的一个引用, 它就是我们熟知的原型链联系.</p><h3 id=方案4-es6-语法糖>方案4: ES6 语法糖</h3><p><img src=https://cdn-images-1.medium.com/max/1600/1*WXIGjN5Dnwv70NcRvVWfyg.jpeg alt=class></p><p>其他允许我们在对象"构造函数"中编写公共方法.ECMAScript6 引入了 <code>class</code> 关键字, 它允许我们编写类似其他语言的普通类. 实际上, 它是 JavaScript 原型行为的语法糖.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>name</span>, <span style=color:#a6e22e>points</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>points</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>points</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>increment</span> () {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>points</span><span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>login</span> () {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#34;Please login.&#34;</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user1</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>User</span>(<span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#ae81ff>12</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>user1</span>.<span style=color:#a6e22e>increment</span>();
</span></span></code></pre></div><p>在方案3, 中使用的 <code>User.prototype.functionName</code> 来精确的实行了关联的方法. 在这个方案中, 我们得到了同样的结果, 但是语法看起来更那个清晰.</p><h2 id=结论>结论</h2><p>现在我们已经了解了更多关于 JavaScript 中创建对象的不同方法. 虽然声明 <code>class</code> 和 <code>new</code> 运算符相对易于使用, 但了解内部的运行机制非常重要.</p><p>回顾一下, 当用 <code>new</code> 调用构造函数时, 会自动执行以下操作:</p><ul><li>创建一个新对象</li><li>把 <code>this</code> 绑定到新对象</li><li>构造函数的原型对象成为新对象的 <code>__proto__</code> 属性</li><li>返回新对象</li></ul><blockquote><p>原文: <a href=https://medium.freecodecamp.org/demystifying-javascripts-new-keyword-874df126184c>Let’s demystify JavaScript&rsquo;s &rsquo;new&rsquo; keyword</a><br>作者: <a href=https://medium.freecodecamp.org/@cynthialixinlee>Cynthia Lee</a><br>发布时间: 2018-04-24</p></blockquote></article></section><footer class="ui attached segment dream-tags"><a class="ui label" href=/tags/javascript title=JavaScript>JavaScript</a><div class="ui label" style=float:right;cursor:pointer onclick=savePostAsImg()><i class="save icon"></i>保存为图片</div></footer><div class=github-comments><script src=https://utteranc.es/client.js repo=BarryYan/barryyan.github.io issue-term=og:title theme=github-light crossorigin=anonymous async></script></div></div><div class="sixteen wide mobile sixteen wide tablet four wide computer column"><article class=dream-header><section class="ui top attached center aligned segment"><div class="ui small circular image"><img src=/me/avatar.jpg></div><h1 class="ui medium header">苏夏天心<div class="sub header" style=margin-top:.5rem>你是什么样的人, 取决于你所做的决定!</div></h1><div class="ui horizontal list"><a class=item href=/tags><i class="tags icon" title=所有标签></i></a>
<a class=item href=/categories><i class="th list icon" title=所有分类></i></a></div></section><section class="ui attached center aligned segment dream-tags"><a class="ui label" href=/tags/education title=education>education</a>
<a class="ui label" href=/tags/image title=image>image</a>
<a class="ui label" href=/tags/javascript title=javascript>javascript</a>
<a class="ui label" href=/tags/map title=map>map</a>
<a class="ui label" href=/tags/music title=music>music</a>
<a class="ui label" href=/tags/nodejs title=nodejs>nodejs</a>
<a class="ui label" href=/tags/novel title=novel>novel</a>
<a class="ui label" href=/tags/v8 title=v8>v8</a>
<a class="ui label" href=/tags/video title=video>video</a>
<a class="ui label" href=/tags/%E6%AD%8C%E8%AF%8D title=歌词>歌词</a></section><section class="ui attached segment dream-categories"><div class="ui accordion"><div class=title><i class="dropdown icon"></i>
<a href=/categories/education class=item>education</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/others/jian-lai/ class=item>剑来</a></div></div><div class=item><div class=content><a href=/others/knowledge-map/ class=item>Knowledge Map</a></div></div></div></div><div class=title><i class="dropdown icon"></i>
<a href=/categories/javascript class=item>javascript</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/program/parse-video-metadata/ class=item>解析视频的元数据</a></div></div><div class=item><div class=content><a href=/program/javascript-the-new-keyword/ class=item>让我们揭开 JavaScript 关键字 new 的神秘面纱</a></div></div><div class=item><div class=content><a href=/program/engin-runtime-call-stack/ class=item>JavaScript 工作原理: 引擎, 运行时和调用栈概述</a></div></div><div class=item><div class=content><a href=/program/inside-the-v8-engin/ class=item>JavaScript 工作原理: V8引擎内部+关于如何编写及优化代码的5条建议</a></div></div></div></div><div class=title><i class="dropdown icon"></i>
<a href=/categories/music class=item>music</a></div><div class=content><div class="ui list"><div class=item><div class=content><a href=/songs/light-dancer/ class=item>轻舞者</a></div></div><div class=item><div class=content><a href=/songs/is-passions-fault/ class=item>是热情惹的错</a></div></div></div></div></div></section><section class="ui attached segment header-socials"><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:barry.yanshg@gmail.com><i class="mail icon" title=Email></i></a></div><div class=item><a href=https://github.com/barryyan target=_blank><i class="github icon" title=GitHub></i></a></div></nav></section><section class="ui bottom attached center aligned segment"><p>© 2019 - 2022 天心阁</p><p>Powered by <a href=https://gohugo.io/ target=_blank>Hugo</a> with theme <a href=https://github.com/barryyan/hugo-theme-dream target=_blank>Dream</a>.</p></section></article></div></div></section><section class=back><nav class="ui secondary inverted menu dream-menu"><div class=item><i class="large link bullseye icon dream-flip-toggle" title=翻转！></i></div><div class=item><i class="large link home icon" title=首页 onclick='window.location.href="https://barryyan.github.io"'></i></div><div class=item><i class="large link icon theme-switch" onclick=themeSwitch()></i></div></nav><div class="ui centered relaxed grid dream-grid dream-back"><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article><div class="ui top attached segment"><h3 class="ui header">开源项目</h3></div><div class="ui attached segment markdown-body"><ul><li><p><a href=https://github.com/BarryYan/daily-warm>daily-warm</a> Send an email to someone you care about everyday, include weather, poem, an ONE word</p></li><li><p><a href=https://github.com/BarryYan/pixi-game>pixi-game</a> A library makes Pixi.js using easily, like phase.js</p></li><li><p><a href=https://github.com/BarryYan/parcel-plugin-css-url-loader>parcel-plugin-css-url-loader</a> A plugin for parcel to convert css/less/scss images url into base64.</p></li><li><p><a href=https://github.com/BarryYan/pre-commit>pre-commit</a> Git hook Check git merger conflict by default</p></li></ul></div></article></section><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article><div class="ui top attached segment"><h3 class="ui header">关于我</h3></div><div class="ui attached segment markdown-body"><h3 id=苏夏天心><strong>苏夏天心</strong></h3><p><code>UI Developer</code> <a href=https://thoughtworks.com>@ThoughtWorks</a></p><p><code>看书</code> - <code>听歌</code> - <code>美食</code> - <code>追剧</code> - <code>英语</code> - <code>Coding</code></p><p>技术栈</p><ul><li>JavaScript & Typescript</li><li>React.js & Vue.js & Angular</li><li>Go</li></ul></div></article></section><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"><article><div class="ui top attached segment"><h3 class="ui header">社交链接</h3></div><div class="ui attached segment"><nav class="ui secondary menu dream-menu dream-socials"><div class=item><a href=/index.xml><i class="large rss square icon" title=RSS></i></a></div><div class=item><a href=mailto:barry.yanshg@gmail.com><i class="large mail icon" title=Email></i></a></div><div class=item><a href=https://github.com/barryyan target=_blank><i class="large github icon" title=GitHub></i></a></div></nav></div></article></section><section class="sixteen wide mobile eight wide tablet four wide computer column dream-column"></section></div></section></div></div><script src=/js/jquery.min.js></script>
<script src=/js/semantic.min.js></script>
<script src=/js/imagesloaded.pkgd.min.js></script>
<script src=/js/masonry.pkgd.min.js></script>
<script src=/js/nav.js></script>
<script src=/js/header.js></script>
<script src=/js/main.js></script>
<script src=/js/theme.js></script>
<script src=/js/html2canvas.min.js></script></body></html>